import asyncio
from telegram import Update, ReplyKeyboardMarkup, KeyboardButton, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes, CallbackQueryHandler
from dataclasses import dataclass, field
from datetime import datetime, timedelta, date, time
import pytz
import logging
from logging.handlers import RotatingFileHandler
import coloredlogs
import sqlite3
import hashlib
import os
import configparser
from tabulate import tabulate
import emoji
import json
from telegram.error import Forbidden, BadRequest
import io
import sys
import codecs

# Cáº¥u hÃ¬nh Ä‘á»ƒ xá»­ lÃ½ Unicode trÃªn Windows
sys.stdout = codecs.getwriter('utf-8')(sys.stdout.buffer, 'strict')
sys.stderr = codecs.getwriter('utf-8')(sys.stderr.buffer, 'strict')

# Cáº¥u hÃ¬nh logging
logger = logging.getLogger(__name__)
coloredlogs.install(level='DEBUG', logger=logger,
                    fmt='%(asctime)s - %(name)s - %(levelname)s - %(message)s')

# ThÃªm file handler Ä‘á»ƒ lÆ°u log vÃ o file vá»›i encoding UTF-8
file_handler = RotatingFileHandler('bot.log', maxBytes=10*1024*1024, backupCount=5, encoding='utf-8')
file_handler.setFormatter(logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s'))
logger.addHandler(file_handler)

# Cáº¥u hÃ¬nh mÃºi giá»
VN_TIMEZONE = pytz.timezone('Asia/Ho_Chi_Minh')

# Äá»c config
config = configparser.ConfigParser()
config.read('config.ini', encoding='utf-8')

# Äá»c token bot
BOT_TOKEN = config['telegram']['YOUR_BOT_TOKEN']

# Äá»c admin_id
ADMIN_ID = [int(id.strip()) for id in config['telegram']['admin_id'].split(',')]
MAIN_ADMIN_ID = ADMIN_ID[0]

# Äá»c authorized_users vÃ  allowed_actions
AUTHORIZED_USERS = [int(user_id) for user_id in config['group_action_permissions']['authorized_users'].split(',')]
ALLOWED_ACTIONS = config['group_action_permissions']['allowed_actions'].split(',')

# Äá»c thá»i gian lÃ m viá»‡c
WORK_START_TIME = datetime.strptime(config['working_hours']['start_time'], '%H:%M').time()
WORK_END_TIME = datetime.strptime(config['working_hours']['end_time'], '%H:%M').time()

# Äá»c thá»i gian nghá»‰
BREAK_DURATIONS = {
    'ğŸš» Vá»‡ sinh (å•æ‰€)': int(config['break_durations']['ve_sinh']),
    'ğŸš¬ HÃºt thuá»‘c (æŠ½çƒŸ)': int(config['break_durations']['hut_thuoc']),
    'ğŸš Ä‚n cÆ¡m (åƒé¥­)': int(config['break_durations']['an_com'])
}

# Äá»c táº§n suáº¥t nghá»‰
BREAK_FREQUENCIES = {
    'ğŸš» Vá»‡ sinh (å•æ‰€)': int(config['break_frequencies']['ve_sinh']),
    'ğŸš¬ HÃºt thuá»‘c (æŠ½çƒŸ)': int(config['break_frequencies']['hut_thuoc']),
    'ğŸš Ä‚n cÆ¡m (åƒé¥­)': int(config['break_frequencies']['an_com'])
}

# Äá»c URL database
DATABASE_URL = config['database']['url']

@dataclass
class UserState:
    user_name: str
    start_time: datetime = None
    end_time: datetime = None
    current_break: str = None
    break_start_time: datetime = None
    breaks: dict = field(default_factory=lambda: {k: timedelta(0) for k in BREAK_DURATIONS.keys()})
    is_working: bool = False
    break_counts: dict = field(default_factory=lambda: {k: 0 for k in BREAK_DURATIONS.keys()})

user_states = {}

def hash_user_id(user_id: int) -> str:
    salt = os.environ.get('USER_ID_SALT', 'default_salt')
    return hashlib.sha256(f"{user_id}{salt}".encode()).hexdigest()

def get_keyboard():
    buttons = [
        [KeyboardButton("ğŸš€ LÃªn ca (ä¸Šç­)"), KeyboardButton("ğŸ Xuá»‘ng ca (ä¸‹ç­)")],
        [KeyboardButton("ğŸš Ä‚n cÆ¡m (åƒé¥­)"), KeyboardButton("ğŸš¬ HÃºt thuá»‘c (æŠ½çƒŸ)")],
        [KeyboardButton("ğŸ’º Trá»Ÿ láº¡i chá»— ngá»“i (è¿”å›)"), KeyboardButton("ğŸš» Vá»‡ sinh (å•æ‰€)")]
    ]
    return ReplyKeyboardMarkup(buttons, resize_keyboard=True)

def get_admin_keyboard():
    buttons = [
        [InlineKeyboardButton("ğŸš€ LÃªn ca táº¥t cáº£", callback_data="all_start_shift"),
         InlineKeyboardButton("ğŸ Xuá»‘ng ca táº¥t cáº£", callback_data="all_end_shift")],
        [InlineKeyboardButton("ğŸš Giá» Äƒn táº¥t cáº£", callback_data="all_eat"),
         InlineKeyboardButton("ğŸ”„ Reset dá»¯ liá»‡u", callback_data="reset_data")]
    ]
    return InlineKeyboardMarkup(buttons)

# Thay Ä‘á»•i biáº¿n global
active_users = set(ADMIN_ID)  # Khá»Ÿi táº¡o vá»›i táº¥t cáº£ admin

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    chat_type = update.effective_chat.type
    
    if chat_type == 'private':
        if user_id == MAIN_ADMIN_ID:
            await update.message.reply_text("ChÃ o má»«ng, Admin chÃ­nh! Báº¡n cÃ³ quyá»n Ä‘iá»u khiá»ƒn Ä‘áº§y Ä‘á»§.", reply_markup=get_keyboard())
        elif user_id in ADMIN_ID:
            await update.message.reply_text("ChÃ o má»«ng, Admin! Báº¡n sáº½ nháº­n Ä‘Æ°á»£c cÃ¡c bÃ¡o cÃ¡o hÃ ng ngÃ y.", reply_markup=get_keyboard())
        else:
            active_users.add(user_id)
            await update.message.reply_text("ChÃ o má»«ng! Vui lÃ²ng chá»n má»™t hÃ nh Ä‘á»™ng:", reply_markup=get_keyboard())
    else:  # Trong nhÃ³m
        await update.message.reply_text("ChÃ o má»«ng! Vui lÃ²ng chá»n má»™t hÃ nh Ä‘á»™ng:", reply_markup=get_keyboard())

    # Gá»­i thÃ´ng bÃ¡o cho táº¥t cáº£ admin khÃ¡c náº¿u ngÆ°á»i dÃ¹ng lÃ  admin
    if user_id in ADMIN_ID:
        for admin_id in ADMIN_ID:
            if admin_id != user_id:
                try:
                    await context.bot.send_message(chat_id=admin_id, text="Bot Ä‘Ã£ Ä‘Æ°á»£c kÃ­ch hoáº¡t bá»Ÿi má»™t admin. Báº¡n cÃ³ thá»ƒ nháº­n thÃ´ng bÃ¡o ngay bÃ¢y giá».")
                except (Forbidden, BadRequest) as e:
                    logger.warning(f"KhÃ´ng thá»ƒ gá»­i tin nháº¯n cho admin {admin_id}. Lá»—i: {str(e)}")

async def button_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    if query.data == "all_start_shift":
        await all_start_shift(update, context)
    elif query.data == "all_end_shift":
        await all_end_shift(update, context)
    elif query.data == "all_eat":
        await all_eat(update, context)
    elif query.data == "reset_data":
        await reset_data(update, context)

async def notify_admin(context: ContextTypes.DEFAULT_TYPE, message: str, notify_all=False):
    admin_list = ADMIN_ID if notify_all else [MAIN_ADMIN_ID]
    for admin_id in admin_list:
        try:
            await context.bot.send_message(chat_id=admin_id, text=emoji.emojize(message))
        except (Forbidden, BadRequest) as e:
            logger.warning(f"KhÃ´ng thá»ƒ gá»­i tin nháº¯n cho admin {admin_id}. Lá»—i: {str(e)}")

def check_break_frequency(user_state: UserState, break_type: str) -> bool:
    return user_state.break_counts[break_type] > BREAK_FREQUENCIES[break_type]

async def handle_break_start(update: Update, context: ContextTypes.DEFAULT_TYPE, user_state: UserState, break_type: str) -> str:
    if not user_state.is_working:
        return "Báº¡n chÆ°a báº¯t Ä‘áº§u ca lÃ m viá»‡c. Vui lÃ²ng lÃªn ca trÆ°á»›c khi báº¯t Ä‘áº§u giá» nghá»‰."
    
    if user_state.current_break:
        return f"Báº¡n Ä‘ang trong giá» nghá»‰ {user_state.current_break}. Vui lÃ²ng káº¿t thÃºc giá» nghá»‰ hiá»‡n táº¡i trÆ°á»›c."
    
    now = datetime.now(VN_TIMEZONE)
    user_state.current_break = break_type
    user_state.break_start_time = now
    user_state.break_counts[break_type] += 1
    
    response = f"â³ Báº¯t Ä‘áº§u {break_type} lÃºc {now.strftime('%H:%M:%S')}. Thá»i gian tá»‘i Ä‘a: {BREAK_DURATIONS[break_type]} phÃºt."
    
    if check_break_frequency(user_state, break_type):
        await notify_admin(context, f"âš ï¸ {user_state.user_name} Ä‘Ã£ báº¯t Ä‘áº§u {break_type} láº§n thá»© {user_state.break_counts[break_type]}, vÆ°á»£t quÃ¡ sá»‘ láº§n quy Ä‘á»‹nh ({BREAK_FREQUENCIES[break_type]}).")
    
    return response

async def handle_break_end(update: Update, context: ContextTypes.DEFAULT_TYPE, user_state: UserState) -> str:
    if not user_state.current_break:
        return "Báº¡n khÃ´ng trong giá» nghá»‰. KhÃ´ng thá»ƒ káº¿t thÃºc giá» nghá»‰."
    
    now = datetime.now(VN_TIMEZONE)
    break_duration = now - user_state.break_start_time
    user_state.breaks[user_state.current_break] += break_duration
    
    response = f"âŒ› Káº¿t thÃºc {user_state.current_break} sau {now.strftime('%H:%M:%S')}.\n"
    
    if break_duration > timedelta(minutes=BREAK_DURATIONS[user_state.current_break]):
        overtime = break_duration - timedelta(minutes=BREAK_DURATIONS[user_state.current_break])
        response += f"âš ï¸ Báº¡n Ä‘Ã£ nghá»‰ quÃ¡ {str(overtime).split('.')[0]} so vá»›i quy Ä‘á»‹nh."
        
        await notify_admin(context, f"âš ï¸ {user_state.user_name} Ä‘Ã£ káº¿t thÃºc {user_state.current_break} sau {str(break_duration).split('.')[0]}, vÆ°á»£t quÃ¡ {str(overtime).split('.')[0]} so vá»›i quy Ä‘á»‹nh.")
    
    # ThÃªm thÃ´ng tin vá» thá»i gian vÃ  sá»‘ láº§n nghá»‰
    response += f"\nThá»i gian nghá»‰: {str(break_duration).split('.')[0]} phÃºt."
    response += f"\nSá»‘ láº§n nghá»‰ {user_state.current_break}: {user_state.break_counts[user_state.current_break]} láº§n."
    
    user_state.current_break = None
    user_state.break_start_time = None
    
    return response

async def handle_start_shift(update: Update, context: ContextTypes.DEFAULT_TYPE, user_state: UserState) -> str:
    if user_state.is_working:
        return "Báº¡n Ä‘Ã£ lÃªn ca rá»“i. KhÃ´ng thá»ƒ lÃªn ca láº¡i."
    
    now = datetime.now(VN_TIMEZONE)
    user_state.start_time = now
    user_state.is_working = True
    
    response = f"âœ… {user_state.user_name} Ä‘Ã£ lÃªn ca lÃºc {now.strftime('%H:%M:%S')}"
    
    is_late = now.time() > WORK_START_TIME
    if is_late:
        late_minutes = (now - now.replace(hour=WORK_START_TIME.hour, minute=WORK_START_TIME.minute, second=0, microsecond=0)).total_seconds() // 60
        response += f"\nâš ï¸ Báº¡n Ä‘Ã£ Ä‘i lÃ m muá»™n {late_minutes:.0f} phÃºt."
        await notify_admin(context, f"âš ï¸ {user_state.user_name} Ä‘Ã£ Ä‘i lÃ m muá»™n {late_minutes:.0f} phÃºt. LÃªn ca lÃºc {now.strftime('%H:%M:%S')}.")
    
    return response

async def handle_end_shift(update: Update, context: ContextTypes.DEFAULT_TYPE, user_state: UserState) -> str:
    if not user_state.is_working:
        return "Báº¡n chÆ°a lÃªn ca. KhÃ´ng thá»ƒ xuá»‘ng ca."
    
    now = datetime.now(VN_TIMEZONE)
    user_state.end_time = now
    user_state.is_working = False
    
    if user_state.current_break:
        user_state.breaks[user_state.current_break] += now - user_state.break_start_time
        user_state.current_break = None
        user_state.break_start_time = None
    
    total_work_time = now - user_state.start_time
    total_break_time = sum(user_state.breaks.values(), timedelta())
    actual_work_time = total_work_time - total_break_time
    
    response = f"ğŸ“… BÃ¡o cÃ¡o ngÃ y {now.strftime('%d/%m/%Y')}:\n\n"
    response += f"ğŸ‘¤ NgÆ°á»i dÃ¹ng: {user_state.user_name}\n"
    response += f"ğŸ†” User ID: {hash_user_id(update.effective_user.id)[:7]}\n"
    response += "------------------------\n"
    response += f"âœ… Xuá»‘ng ca - {now.strftime('%d/%m/%Y %H:%M:%S')}\n"
    response += "------------------------\n"
    response += f"â° Thá»i gian lÃ m viá»‡c: {str(total_work_time).split('.')[0]}\n"
    response += f"âš™ï¸ Thá»i gian lÃ m viá»‡c thá»±c táº¿: {str(actual_work_time).split('.')[0]}\n"
    response += "------------------------\n"
    response += f"ğŸ“Š Tá»•ng thá»i gian nghá»‰: {str(total_break_time).split('.')[0]}\n"
    for break_type, duration in user_state.breaks.items():
        response += f"{break_type}: {str(duration).split('.')[0]} ({user_state.break_counts[break_type]} láº§n)\n"
    response += "------------------------\n"
    response += f"âœ… {user_state.user_name} Ä‘Ã£ xuá»‘ng ca."
    
    return response

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    hashed_user_id = hash_user_id(user_id)
    message_text = update.message.text
    
    if hashed_user_id not in user_states:
        user_states[hashed_user_id] = UserState(user_name=update.effective_user.full_name)
    
    user_state = user_states[hashed_user_id]
    
    if message_text == "ğŸš€ LÃªn ca (ä¸Šç­)":
        response = await handle_start_shift(update, context, user_state)
    elif message_text == "ğŸ Xuá»‘ng ca (ä¸‹ç­)":
        response = await handle_end_shift(update, context, user_state)
    elif message_text in ["ğŸš Ä‚n cÆ¡m (åƒé¥­)", "ğŸš¬ HÃºt thuá»‘c (æŠ½çƒŸ)", "ğŸš» Vá»‡ sinh (å•æ‰€)"]:
        response = await handle_break_start(update, context, user_state, message_text)
    elif message_text == "ğŸ’º Trá»Ÿ láº¡i chá»— ngá»“i (è¿”å›)":
        response = await handle_break_end(update, context, user_state)
        response += f"\nâœ… {user_state.user_name} Ä‘Ã£ Trá»Ÿ láº¡i chá»— ngá»“i (è¿”å›)."
    else:
        response = "Vui lÃ²ng chá»n má»™t hÃ nh Ä‘á»™ng tá»« bÃ n phÃ­m."
    
    if response:
        await update.message.reply_text(response, reply_markup=get_keyboard())

async def periodic_check(context: ContextTypes.DEFAULT_TYPE):
    logger.info("Running periodic check")
    now = datetime.now(VN_TIMEZONE)
    for hashed_user_id, user_state in user_states.items():
        if user_state.is_working and user_state.current_break:
            break_duration = now - user_state.break_start_time
            if break_duration > timedelta(minutes=BREAK_DURATIONS[user_state.current_break]):
                logger.warning(f"{user_state.user_name} is on an extended {user_state.current_break} break")
                overtime = break_duration - timedelta(minutes=BREAK_DURATIONS[user_state.current_break])
                try:
                    await notify_admin(context, f"âš ï¸ {user_state.user_name} Ä‘ang trong giá» nghá»‰ {user_state.current_break} quÃ¡ {overtime}.")
                except Exception as e:
                    logger.error(f"Lá»—i khi gá»­i thÃ´ng bÃ¡o cho admin: {str(e)}")

async def error_handler(update: object, context: ContextTypes.DEFAULT_TYPE):
    logger.error(f"Exception while handling an update: {context.error}")
    if isinstance(context.error, (Forbidden, BadRequest)):
        logger.warning(f"Telegram API error: {str(context.error)}")
    else:
        # Xá»­ lÃ½ cÃ¡c loáº¡i lá»—i khÃ¡c á»Ÿ Ä‘Ã¢y
        pass

def init_db():
    conn = sqlite3.connect('user_states.db')
    c = conn.cursor()
    c.execute('''CREATE TABLE IF NOT EXISTS user_states
                 (hashed_user_id TEXT PRIMARY KEY, user_data TEXT)''')
    conn.commit()
    conn.close()

def save_user_state(hashed_user_id: str, user_state: UserState):
    logger.debug(f"LÆ°u tráº¡ng thÃ¡i cho user {user_state.user_name}")
    conn = sqlite3.connect('user_states.db')
    c = conn.cursor()
    user_data = {
        'user_name': user_state.user_name,
        'start_time': user_state.start_time.isoformat() if user_state.start_time else None,
        'end_time': user_state.end_time.isoformat() if user_state.end_time else None,
        'current_break': user_state.current_break,
        'break_start_time': user_state.break_start_time.isoformat() if user_state.break_start_time else None,
        'is_working': user_state.is_working
    }
    c.execute("INSERT OR REPLACE INTO user_states (hashed_user_id, user_data) VALUES (?, ?)",
              (hashed_user_id, json.dumps(user_data)))
    conn.commit()
    conn.close()

def load_user_states():
    logger.info("Äang táº£i tráº¡ng thÃ¡i cá»§a táº¥t cáº£ ngÆ°á»i dÃ¹ng")
    conn = sqlite3.connect('user_states.db')
    c = conn.cursor()
    c.execute("SELECT * FROM user_states")
    rows = c.fetchall()
    conn.close()

    loaded_states = {}
    for row in rows:
        hashed_user_id, user_data_json = row
        user_data = json.loads(user_data_json)
        user_state = UserState(user_name=user_data['user_name'])
        user_state.start_time = datetime.fromisoformat(user_data['start_time']) if user_data.get('start_time') else None
        user_state.current_break = user_data.get('current_break')
        user_state.break_start_time = datetime.fromisoformat(user_data['break_start_time']) if user_data.get('break_start_time') else None
        user_state.is_working = user_data.get('is_working', False)
        user_state.end_time = datetime.fromisoformat(user_data['end_time']) if user_data.get('end_time') else None
        loaded_states[hashed_user_id] = user_state
    logger.info(f"ÄÃ£ táº£i {len(loaded_states)} tráº¡ng thÃ¡i ngÆ°á»i dÃ¹ng")
    return loaded_states

async def save_all_user_states(context: ContextTypes.DEFAULT_TYPE):
    logger.info("Saving all user states")
    for hashed_user_id, user_state in user_states.items():
        save_user_state(hashed_user_id, user_state)
    logger.info("All user states saved successfully")

async def reset_data(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    if user_id != MAIN_ADMIN_ID:
        await update.message.reply_text("Báº¡n khÃ´ng cÃ³ quyá»n thá»±c hiá»‡n hÃ nh Ä‘á»™ng nÃ y.")
        return

    global user_states
    user_states = {}
    
    # XÃ³a dá»¯ liá»‡u trong database
    conn = sqlite3.connect('user_states.db')
    c = conn.cursor()
    c.execute("DELETE FROM user_states")
    conn.commit()
    conn.close()

    logger.info("ÄÃ£ reset toÃ n bá»™ dá»¯ liá»‡u")
    await update.message.reply_text("ÄÃ£ reset toÃ n bá»™ dá»¯ liá»‡u thÃ nh cÃ´ng.")
    await notify_admin(context, "ğŸ”„ ToÃ n bá»™ dá»¯ liá»‡u Ä‘Ã£ Ä‘Æ°á»£c reset.")

async def all_start_shift(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    if user_id != MAIN_ADMIN_ID:
        await update.message.reply_text("Báº¡n khÃ´ng cÃ³ quyá»n thá»±c hiá»‡n hÃ nh Ä‘á»™ng nÃ y.")
        return

    now = datetime.now(VN_TIMEZONE)
    for hashed_user_id, user_state in user_states.items():
        if not user_state.is_working:
            user_state.start_time = now
            user_state.is_working = True
            save_user_state(hashed_user_id, user_state)
    
    logger.info("ÄÃ£ báº¯t Ä‘áº§u ca lÃ m viá»‡c cho táº¥t cáº£ ngÆ°á»i dÃ¹ng")
    await update.message.reply_text("ÄÃ£ báº¯t Ä‘áº§u ca lÃ m viá»‡c cho táº¥t cáº£ ngÆ°á»i dÃ¹ng.")
    await notify_admin(context, "ğŸš€ ÄÃ£ báº¯t Ä‘áº§u ca lÃ m viá»‡c cho táº¥t cáº£ ngÆ°á»i dÃ¹ng.")

async def all_end_shift(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    if user_id != MAIN_ADMIN_ID:
        await update.message.reply_text("Báº¡n khÃ´ng cÃ³ quyá»n thá»±c hiá»‡n hÃ nh Ä‘á»™ng nÃ y.")
        return

    now = datetime.now(VN_TIMEZONE)
    for hashed_user_id, user_state in user_states.items():
        if user_state.is_working:
            user_state.end_time = now
            user_state.is_working = False
            if user_state.current_break:
                user_state.breaks[user_state.current_break] += now - user_state.break_start_time
                user_state.current_break = None
                user_state.break_start_time = None
            save_user_state(hashed_user_id, user_state)
    
    logger.info("ÄÃ£ káº¿t thÃºc ca lÃ m viá»‡c cho táº¥t cáº£ ngÆ°á»i dÃ¹ng")
    await update.message.reply_text("ÄÃ£ káº¿t thÃºc ca lÃ m viá»‡c cho táº¥t cáº£ ngÆ°á»i dÃ¹ng.")
    await notify_admin(context, "ğŸ ÄÃ£ káº¿t thÃºc ca lÃ m viá»‡c cho táº¥t cáº£ ngÆ°á»i dÃ¹ng.")

async def all_eat(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    if user_id != MAIN_ADMIN_ID:
        await update.message.reply_text("Báº¡n khÃ´ng cÃ³ quyá»n thá»±c hiá»‡n hÃ nh Ä‘á»™ng nÃ y.")
        return

    now = datetime.now(VN_TIMEZONE)
    for hashed_user_id, user_state in user_states.items():
        if user_state.is_working and not user_state.current_break:
            user_state.current_break = 'ğŸš Ä‚n cÆ¡m (åƒé¥­)'
            user_state.break_start_time = now
            user_state.break_counts['ğŸš Ä‚n cÆ¡m (åƒé¥­)'] += 1
            save_user_state(hashed_user_id, user_state)
    
    logger.info("ÄÃ£ báº¯t Ä‘áº§u giá» Äƒn cho táº¥t cáº£ ngÆ°á»i dÃ¹ng Ä‘ang lÃ m viá»‡c")
    await update.message.reply_text("ÄÃ£ báº¯t Ä‘áº§u giá» Äƒn cho táº¥t cáº£ ngÆ°á»i dÃ¹ng Ä‘ang lÃ m viá»‡c.")
    await notify_admin(context, "ğŸš ÄÃ£ báº¯t Ä‘áº§u giá» Äƒn cho táº¥t cáº£ ngÆ°á»i dÃ¹ng Ä‘ang lÃ m viá»‡c.")

async def auto_end_shift(context: ContextTypes.DEFAULT_TYPE):
    now = datetime.now(VN_TIMEZONE)
    for hashed_user_id, user_state in user_states.items():
        if user_state.is_working:
            user_state.end_time = now
            user_state.is_working = False
            if user_state.current_break:
                user_state.breaks[user_state.current_break] += now - user_state.break_start_time
                user_state.current_break = None
                user_state.break_start_time = None
            
            report = generate_simple_report(user_state, hashed_user_id)
            save_user_state(hashed_user_id, user_state)
            
            try:
                await context.bot.send_message(chat_id=int(hashed_user_id, 16), text=report)
            except Exception as e:
                logger.error(f"KhÃ´ng thá»ƒ gá»­i bÃ¡o cÃ¡o cho user {user_state.user_name}: {str(e)}")

async def send_daily_report(context: ContextTypes.DEFAULT_TYPE):
    now = datetime.now(VN_TIMEZONE)
    yesterday = now - timedelta(days=1)
    report = f"ğŸ“Š BÃ¡o cÃ¡o cuá»‘i ngÃ y {yesterday.strftime('%d/%m/%Y')}:\n\n"

    user_reports = []
    for hashed_user_id, user_state in user_states.items():
        if user_state.start_time and user_state.start_time.date() == yesterday.date():
            user_report = generate_simple_report(user_state, hashed_user_id)
            if user_report:
                user_reports.append(user_report)

    if user_reports:
        report += "\n".join(user_reports)
    else:
        report += "KhÃ´ng cÃ³ dá»¯ liá»‡u bÃ¡o cÃ¡o cho ngÃ y hÃ´m qua."

    await notify_admin(context, report, notify_all=True)

    # Reset user states for the new day
    for user_state in user_states.values():
        user_state.start_time = None
        user_state.end_time = None
    user_state.breaks = {k: timedelta(0) for k in BREAK_DURATIONS.keys()}
    user_state.current_break = None
    user_state.break_start_time = None
    user_state.is_working = False
    user_state.break_counts = {k: 0 for k in BREAK_DURATIONS.keys()}

def main():
    init_db()
    global user_states
    user_states = load_user_states()

    application = Application.builder().token(BOT_TOKEN).build()

    application.add_handler(CommandHandler("start", start))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))
    application.add_handler(CallbackQueryHandler(button_callback))

    job_queue = application.job_queue
    job_queue.run_repeating(periodic_check, interval=timedelta(minutes=15), first=10)
    job_queue.run_repeating(save_all_user_states, interval=timedelta(minutes=5), first=5)
    
    # ThÃªm job Ä‘á»ƒ tá»± Ä‘á»™ng káº¿t thÃºc ca lÃ m viá»‡c lÃºc 1:00 AM
    job_queue.run_daily(auto_end_shift, time=time(hour=1, minute=0))
    
    # Cáº­p nháº­t job gá»­i bÃ¡o cÃ¡o hÃ ng ngÃ y Ä‘á»ƒ cháº¡y lÃºc 1:05 AM
    job_queue.run_daily(send_daily_report, time=time(hour=1, minute=5))

    application.add_error_handler(error_handler)

    application.run_polling()

if __name__ == '__main__':
    main()