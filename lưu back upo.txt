import asyncio
from telegram import Update, ReplyKeyboardMarkup, KeyboardButton, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes, CallbackQueryHandler
from dataclasses import dataclass, field
from datetime import datetime, timedelta, date, time
import pytz
import logging
from logging.handlers import RotatingFileHandler
import coloredlogs
import sqlite3
import hashlib
import os
import configparser
from tabulate import tabulate
import emoji
import json
from telegram.error import Forbidden, BadRequest
import io
import sys
import codecs

# C·∫•u h√¨nh ƒë·ªÉ x·ª≠ l√Ω Unicode tr√™n Windows
sys.stdout = codecs.getwriter('utf-8')(sys.stdout.buffer, 'strict')
sys.stderr = codecs.getwriter('utf-8')(sys.stderr.buffer, 'strict')

# C·∫•u h√¨nh logging
logger = logging.getLogger(__name__)
coloredlogs.install(level='DEBUG', logger=logger,
                    fmt='%(asctime)s - %(name)s - %(levelname)s - %(message)s')

# Th√™m file handler ƒë·ªÉ l∆∞u log v√†o file v·ªõi encoding UTF-8
file_handler = RotatingFileHandler('bot.log', maxBytes=10*1024*1024, backupCount=5, encoding='utf-8')
file_handler.setFormatter(logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s'))
logger.addHandler(file_handler)

# C·∫•u h√¨nh m√∫i gi·ªù
VN_TIMEZONE = pytz.timezone('Asia/Ho_Chi_Minh')

# ƒê·ªçc config
config = configparser.ConfigParser()
config.read('config.ini', encoding='utf-8')

# ƒê·ªçc token bot
BOT_TOKEN = config['telegram']['YOUR_BOT_TOKEN']

# ƒê·ªçc admin_id
ADMIN_ID = [int(id.strip()) for id in config['telegram']['admin_id'].split(',')]
MAIN_ADMIN_ID = ADMIN_ID[0]

# ƒê·ªçc authorized_users v√† allowed_actions
AUTHORIZED_USERS = [int(user_id) for user_id in config['group_action_permissions']['authorized_users'].split(',')]
ALLOWED_ACTIONS = config['group_action_permissions']['allowed_actions'].split(',')

# ƒê·ªçc th·ªùi gian l√†m vi·ªác
WORK_START_TIME = datetime.strptime(config['working_hours']['start_time'], '%H:%M').time()
WORK_END_TIME = datetime.strptime(config['working_hours']['end_time'], '%H:%M').time()

# ƒê·ªçc th·ªùi gian ngh·ªâ
BREAK_DURATIONS = {
    'üöª V·ªá sinh (ÂéïÊâÄ)': int(config['break_durations']['ve_sinh']),
    'üö¨ H√∫t thu·ªëc (ÊäΩÁÉü)': int(config['break_durations']['hut_thuoc']),
    'üçö ƒÇn c∆°m (ÂêÉÈ•≠)': int(config['break_durations']['an_com'])
}

# ƒê·ªçc t·∫ßn su·∫•t ngh·ªâ
BREAK_FREQUENCIES = {
    'üöª V·ªá sinh (ÂéïÊâÄ)': int(config['break_frequencies']['ve_sinh']),
    'üö¨ H√∫t thu·ªëc (ÊäΩÁÉü)': int(config['break_frequencies']['hut_thuoc']),
    'üçö ƒÇn c∆°m (ÂêÉÈ•≠)': int(config['break_frequencies']['an_com'])
}

# ƒê·ªçc URL database
DATABASE_URL = config['database']['url']

@dataclass
class UserState:
    user_name: str
    start_time: datetime = None
    end_time: datetime = None
    current_break: str = None
    break_start_time: datetime = None
    breaks: dict = field(default_factory=lambda: {k: timedelta(0) for k in BREAK_DURATIONS.keys()})
    is_working: bool = False
    break_counts: dict = field(default_factory=lambda: {k: 0 for k in BREAK_DURATIONS.keys()})

user_states = {}

def hash_user_id(user_id: int) -> str:
    salt = os.environ.get('USER_ID_SALT', 'default_salt')
    return hashlib.sha256(f"{user_id}{salt}".encode()).hexdigest()

def get_keyboard():
    buttons = [
        [KeyboardButton("üöÄ L√™n ca (‰∏äÁè≠)"), KeyboardButton("üèÅ Xu·ªëng ca (‰∏ãÁè≠)")],
        [KeyboardButton("üçö ƒÇn c∆°m (ÂêÉÈ•≠)"), KeyboardButton("üö¨ H√∫t thu·ªëc (ÊäΩÁÉü)")],
        [KeyboardButton("üí∫ Tr·ªü l·∫°i ch·ªó ng·ªìi (ËøîÂõû)"), KeyboardButton("üöª V·ªá sinh (ÂéïÊâÄ)")]
    ]
    return ReplyKeyboardMarkup(buttons, resize_keyboard=True)

def get_admin_keyboard():
    buttons = [
        [InlineKeyboardButton("üöÄ L√™n ca t·∫•t c·∫£", callback_data="all_start_shift"),
         InlineKeyboardButton("üèÅ Xu·ªëng ca t·∫•t c·∫£", callback_data="all_end_shift")],
        [InlineKeyboardButton("üçö Gi·ªù ƒÉn t·∫•t c·∫£", callback_data="all_eat"),
         InlineKeyboardButton("üîÑ Reset d·ªØ li·ªáu", callback_data="reset_data")]
    ]
    return InlineKeyboardMarkup(buttons)

# Thay ƒë·ªïi bi·∫øn global
active_users = set(ADMIN_ID)  # Kh·ªüi t·∫°o v·ªõi t·∫•t c·∫£ admin

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    chat_type = update.effective_chat.type
    
    if chat_type == 'private':
        if user_id == MAIN_ADMIN_ID:
            await update.message.reply_text("Ch√†o m·ª´ng, Admin ch√≠nh! B·∫°n c√≥ quy·ªÅn ƒëi·ªÅu khi·ªÉn ƒë·∫ßy ƒë·ªß.", reply_markup=get_keyboard())
        elif user_id in ADMIN_ID:
            await update.message.reply_text("Ch√†o m·ª´ng, Admin! B·∫°n s·∫Ω nh·∫≠n ƒë∆∞·ª£c c√°c b√°o c√°o h√†ng ng√†y.", reply_markup=get_keyboard())
        else:
            active_users.add(user_id)
            await update.message.reply_text("Ch√†o m·ª´ng! Vui l√≤ng ch·ªçn m·ªôt h√†nh ƒë·ªông:", reply_markup=get_keyboard())
    else:  # Trong nh√≥m
        await update.message.reply_text("Ch√†o m·ª´ng! Vui l√≤ng ch·ªçn m·ªôt h√†nh ƒë·ªông:", reply_markup=get_keyboard())

    # G·ª≠i th√¥ng b√°o cho t·∫•t c·∫£ admin kh√°c n·∫øu ng∆∞·ªùi d√πng l√† admin
    if user_id in ADMIN_ID:
        for admin_id in ADMIN_ID:
            if admin_id != user_id:
                try:
                    await context.bot.send_message(chat_id=admin_id, text="Bot ƒë√£ ƒë∆∞·ª£c k√≠ch ho·∫°t b·ªüi m·ªôt admin. B·∫°n c√≥ th·ªÉ nh·∫≠n th√¥ng b√°o ngay b√¢y gi·ªù.")
                except (Forbidden, BadRequest) as e:
                    logger.warning(f"Kh√¥ng th·ªÉ g·ª≠i tin nh·∫Øn cho admin {admin_id}. L·ªói: {str(e)}")

async def button_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    if query.data == "all_start_shift":
        await all_start_shift(update, context)
    elif query.data == "all_end_shift":
        await all_end_shift(update, context)
    elif query.data == "all_eat":
        await all_eat(update, context)
    elif query.data == "reset_data":
        await reset_data(update, context)

async def notify_admin(context: ContextTypes.DEFAULT_TYPE, message: str, notify_all=False):
    admin_list = ADMIN_ID if notify_all else [MAIN_ADMIN_ID]
    for admin_id in admin_list:
        try:
            await context.bot.send_message(chat_id=admin_id, text=emoji.emojize(message))
        except (Forbidden, BadRequest) as e:
            logger.warning(f"Kh√¥ng th·ªÉ g·ª≠i tin nh·∫Øn cho admin {admin_id}. L·ªói: {str(e)}")

def check_break_frequency(user_state: UserState, break_type: str) -> bool:
    return user_state.break_counts[break_type] > BREAK_FREQUENCIES[break_type]

async def handle_break_start(update: Update, context: ContextTypes.DEFAULT_TYPE, user_state: UserState, break_type: str) -> str:
    if not user_state.is_working:
        return "B·∫°n ch∆∞a b·∫Øt ƒë·∫ßu ca l√†m vi·ªác. Vui l√≤ng l√™n ca tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu gi·ªù ngh·ªâ."
    
    if user_state.current_break:
        return f"B·∫°n ƒëang trong gi·ªù ngh·ªâ {user_state.current_break}. Vui l√≤ng k·∫øt th√∫c gi·ªù ngh·ªâ hi·ªán t·∫°i tr∆∞·ªõc."
    
    now = datetime.now(VN_TIMEZONE)
    user_state.current_break = break_type
    user_state.break_start_time = now
    user_state.break_counts[break_type] += 1
    
    response = f"‚è≥ B·∫Øt ƒë·∫ßu {break_type} l√∫c {now.strftime('%H:%M:%S')}. Th·ªùi gian t·ªëi ƒëa: {BREAK_DURATIONS[break_type]} ph√∫t."
    
    if check_break_frequency(user_state, break_type):
        await notify_admin(context, f"‚ö†Ô∏è {user_state.user_name} ƒë√£ b·∫Øt ƒë·∫ßu {break_type} l·∫ßn th·ª© {user_state.break_counts[break_type]}, v∆∞·ª£t qu√° s·ªë l·∫ßn quy ƒë·ªãnh ({BREAK_FREQUENCIES[break_type]}).")
    
    return response

async def handle_break_end(update: Update, context: ContextTypes.DEFAULT_TYPE, user_state: UserState) -> str:
    if not user_state.current_break:
        return "B·∫°n kh√¥ng trong gi·ªù ngh·ªâ. Kh√¥ng th·ªÉ k·∫øt th√∫c gi·ªù ngh·ªâ."
    
    now = datetime.now(VN_TIMEZONE)
    break_duration = now - user_state.break_start_time
    user_state.breaks[user_state.current_break] += break_duration
    
    response = f"‚åõ K·∫øt th√∫c {user_state.current_break} sau {now.strftime('%H:%M:%S')}.\n"
    
    if break_duration > timedelta(minutes=BREAK_DURATIONS[user_state.current_break]):
        overtime = break_duration - timedelta(minutes=BREAK_DURATIONS[user_state.current_break])
        response += f"‚ö†Ô∏è B·∫°n ƒë√£ ngh·ªâ qu√° {str(overtime).split('.')[0]} so v·ªõi quy ƒë·ªãnh."
        
        await notify_admin(context, f"‚ö†Ô∏è {user_state.user_name} ƒë√£ k·∫øt th√∫c {user_state.current_break} sau {str(break_duration).split('.')[0]}, v∆∞·ª£t qu√° {str(overtime).split('.')[0]} so v·ªõi quy ƒë·ªãnh.")
    
    # Th√™m th√¥ng tin v·ªÅ th·ªùi gian v√† s·ªë l·∫ßn ngh·ªâ
    response += f"\nTh·ªùi gian ngh·ªâ: {str(break_duration).split('.')[0]} ph√∫t."
    response += f"\nS·ªë l·∫ßn ngh·ªâ {user_state.current_break}: {user_state.break_counts[user_state.current_break]} l·∫ßn."
    
    user_state.current_break = None
    user_state.break_start_time = None
    
    return response

async def handle_start_shift(update: Update, context: ContextTypes.DEFAULT_TYPE, user_state: UserState) -> str:
    if user_state.is_working:
        return "B·∫°n ƒë√£ l√™n ca r·ªìi. Kh√¥ng th·ªÉ l√™n ca l·∫°i."
    
    now = datetime.now(VN_TIMEZONE)
    user_state.start_time = now
    user_state.is_working = True
    
    response = f"‚úÖ {user_state.user_name} ƒë√£ l√™n ca l√∫c {now.strftime('%H:%M:%S')}"
    
    is_late = now.time() > WORK_START_TIME
    if is_late:
        late_minutes = (now - now.replace(hour=WORK_START_TIME.hour, minute=WORK_START_TIME.minute, second=0, microsecond=0)).total_seconds() // 60
        response += f"\n‚ö†Ô∏è B·∫°n ƒë√£ ƒëi l√†m mu·ªôn {late_minutes:.0f} ph√∫t."
        await notify_admin(context, f"‚ö†Ô∏è {user_state.user_name} ƒë√£ ƒëi l√†m mu·ªôn {late_minutes:.0f} ph√∫t. L√™n ca l√∫c {now.strftime('%H:%M:%S')}.")
    
    return response

async def handle_end_shift(update: Update, context: ContextTypes.DEFAULT_TYPE, user_state: UserState) -> str:
    if not user_state.is_working:
        return "B·∫°n ch∆∞a l√™n ca. Kh√¥ng th·ªÉ xu·ªëng ca."
    
    now = datetime.now(VN_TIMEZONE)
    user_state.end_time = now
    user_state.is_working = False
    
    if user_state.current_break:
        user_state.breaks[user_state.current_break] += now - user_state.break_start_time
        user_state.current_break = None
        user_state.break_start_time = None
    
    total_work_time = now - user_state.start_time
    total_break_time = sum(user_state.breaks.values(), timedelta())
    actual_work_time = total_work_time - total_break_time
    
    response = f"üìÖ B√°o c√°o ng√†y {now.strftime('%d/%m/%Y')}:\n\n"
    response += f"üë§ Ng∆∞·ªùi d√πng: {user_state.user_name}\n"
    response += f"üÜî User ID: {hash_user_id(update.effective_user.id)[:7]}\n"
    response += "------------------------\n"
    response += f"‚úÖ Xu·ªëng ca - {now.strftime('%d/%m/%Y %H:%M:%S')}\n"
    response += "------------------------\n"
    response += f"‚è∞ Th·ªùi gian l√†m vi·ªác: {str(total_work_time).split('.')[0]}\n"
    response += f"‚öôÔ∏è Th·ªùi gian l√†m vi·ªác th·ª±c t·∫ø: {str(actual_work_time).split('.')[0]}\n"
    response += "------------------------\n"
    response += f"üìä T·ªïng th·ªùi gian ngh·ªâ: {str(total_break_time).split('.')[0]}\n"
    for break_type, duration in user_state.breaks.items():
        response += f"{break_type}: {str(duration).split('.')[0]} ({user_state.break_counts[break_type]} l·∫ßn)\n"
    response += "------------------------\n"
    response += f"‚úÖ {user_state.user_name} ƒë√£ xu·ªëng ca."
    
    return response

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    hashed_user_id = hash_user_id(user_id)
    message_text = update.message.text
    
    if hashed_user_id not in user_states:
        user_states[hashed_user_id] = UserState(user_name=update.effective_user.full_name)
    
    user_state = user_states[hashed_user_id]
    
    if message_text == "üöÄ L√™n ca (‰∏äÁè≠)":
        response = await handle_start_shift(update, context, user_state)
    elif message_text == "üèÅ Xu·ªëng ca (‰∏ãÁè≠)":
        response = await handle_end_shift(update, context, user_state)
    elif message_text in ["üçö ƒÇn c∆°m (ÂêÉÈ•≠)", "üö¨ H√∫t thu·ªëc (ÊäΩÁÉü)", "üöª V·ªá sinh (ÂéïÊâÄ)"]:
        response = await handle_break_start(update, context, user_state, message_text)
    elif message_text == "üí∫ Tr·ªü l·∫°i ch·ªó ng·ªìi (ËøîÂõû)":
        response = await handle_break_end(update, context, user_state)
        response += f"\n‚úÖ {user_state.user_name} ƒë√£ Tr·ªü l·∫°i ch·ªó ng·ªìi (ËøîÂõû)."
    else:
        response = "Vui l√≤ng ch·ªçn m·ªôt h√†nh ƒë·ªông t·ª´ b√†n ph√≠m."
    
    if response:
        await update.message.reply_text(response, reply_markup=get_keyboard())

async def periodic_check(context: ContextTypes.DEFAULT_TYPE):
    logger.info("Running periodic check")
    now = datetime.now(VN_TIMEZONE)
    for hashed_user_id, user_state in user_states.items():
        if user_state.is_working and user_state.current_break:
            break_duration = now - user_state.break_start_time
            if break_duration > timedelta(minutes=BREAK_DURATIONS[user_state.current_break]):
                logger.warning(f"{user_state.user_name} is on an extended {user_state.current_break} break")
                overtime = break_duration - timedelta(minutes=BREAK_DURATIONS[user_state.current_break])
                try:
                    await notify_admin(context, f"‚ö†Ô∏è {user_state.user_name} ƒëang trong gi·ªù ngh·ªâ {user_state.current_break} qu√° {overtime}.")
                except Exception as e:
                    logger.error(f"L·ªói khi g·ª≠i th√¥ng b√°o cho admin: {str(e)}")

async def error_handler(update: object, context: ContextTypes.DEFAULT_TYPE):
    logger.error(f"Exception while handling an update: {context.error}")
    if isinstance(context.error, (Forbidden, BadRequest)):
        logger.warning(f"Telegram API error: {str(context.error)}")
    else:
        # X·ª≠ l√Ω c√°c lo·∫°i l·ªói kh√°c ·ªü ƒë√¢y
        pass

def init_db():
    conn = sqlite3.connect('user_states.db')
    c = conn.cursor()
    c.execute('''CREATE TABLE IF NOT EXISTS user_states
                 (hashed_user_id TEXT PRIMARY KEY, user_data TEXT)''')
    conn.commit()
    conn.close()

def save_user_state(hashed_user_id: str, user_state: UserState):
    logger.debug(f"L∆∞u tr·∫°ng th√°i cho user {user_state.user_name}")
    conn = sqlite3.connect('user_states.db')
    c = conn.cursor()
    user_data = {
        'user_name': user_state.user_name,
        'start_time': user_state.start_time.isoformat() if user_state.start_time else None,
        'end_time': user_state.end_time.isoformat() if user_state.end_time else None,
        'current_break': user_state.current_break,
        'break_start_time': user_state.break_start_time.isoformat() if user_state.break_start_time else None,
        'is_working': user_state.is_working
    }
    c.execute("INSERT OR REPLACE INTO user_states (hashed_user_id, user_data) VALUES (?, ?)",
              (hashed_user_id, json.dumps(user_data)))
    conn.commit()
    conn.close()

def load_user_states():
    logger.info("ƒêang t·∫£i tr·∫°ng th√°i c·ªßa t·∫•t c·∫£ ng∆∞·ªùi d√πng")
    conn = sqlite3.connect('user_states.db')
    c = conn.cursor()
    c.execute("SELECT * FROM user_states")
    rows = c.fetchall()
    conn.close()

    loaded_states = {}
    for row in rows:
        hashed_user_id, user_data_json = row
        user_data = json.loads(user_data_json)
        user_state = UserState(user_name=user_data['user_name'])
        user_state.start_time = datetime.fromisoformat(user_data['start_time']) if user_data.get('start_time') else None
        user_state.current_break = user_data.get('current_break')
        user_state.break_start_time = datetime.fromisoformat(user_data['break_start_time']) if user_data.get('break_start_time') else None
        user_state.is_working = user_data.get('is_working', False)
        user_state.end_time = datetime.fromisoformat(user_data['end_time']) if user_data.get('end_time') else None
        loaded_states[hashed_user_id] = user_state
    logger.info(f"ƒê√£ t·∫£i {len(loaded_states)} tr·∫°ng th√°i ng∆∞·ªùi d√πng")
    return loaded_states

async def save_all_user_states(context: ContextTypes.DEFAULT_TYPE):
    logger.info("Saving all user states")
    for hashed_user_id, user_state in user_states.items():
        save_user_state(hashed_user_id, user_state)
    logger.info("All user states saved successfully")

async def reset_data(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    if user_id != MAIN_ADMIN_ID:
        await update.message.reply_text("B·∫°n kh√¥ng c√≥ quy·ªÅn th·ª±c hi·ªán h√†nh ƒë·ªông n√†y.")
        return

    global user_states
    user_states = {}
    
    # X√≥a d·ªØ li·ªáu trong database
    conn = sqlite3.connect('user_states.db')
    c = conn.cursor()
    c.execute("DELETE FROM user_states")
    conn.commit()
    conn.close()

    logger.info("ƒê√£ reset to√†n b·ªô d·ªØ li·ªáu")
    await update.message.reply_text("ƒê√£ reset to√†n b·ªô d·ªØ li·ªáu th√†nh c√¥ng.")
    await notify_admin(context, "üîÑ To√†n b·ªô d·ªØ li·ªáu ƒë√£ ƒë∆∞·ª£c reset.")

async def all_start_shift(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    if user_id != MAIN_ADMIN_ID:
        await update.message.reply_text("B·∫°n kh√¥ng c√≥ quy·ªÅn th·ª±c hi·ªán h√†nh ƒë·ªông n√†y.")
        return

    now = datetime.now(VN_TIMEZONE)
    for hashed_user_id, user_state in user_states.items():
        if not user_state.is_working:
            user_state.start_time = now
            user_state.is_working = True
            save_user_state(hashed_user_id, user_state)
    
    logger.info("ƒê√£ b·∫Øt ƒë·∫ßu ca l√†m vi·ªác cho t·∫•t c·∫£ ng∆∞·ªùi d√πng")
    await update.message.reply_text("ƒê√£ b·∫Øt ƒë·∫ßu ca l√†m vi·ªác cho t·∫•t c·∫£ ng∆∞·ªùi d√πng.")
    await notify_admin(context, "üöÄ ƒê√£ b·∫Øt ƒë·∫ßu ca l√†m vi·ªác cho t·∫•t c·∫£ ng∆∞·ªùi d√πng.")

async def all_end_shift(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    if user_id != MAIN_ADMIN_ID:
        await update.message.reply_text("B·∫°n kh√¥ng c√≥ quy·ªÅn th·ª±c hi·ªán h√†nh ƒë·ªông n√†y.")
        return

    now = datetime.now(VN_TIMEZONE)
    for hashed_user_id, user_state in user_states.items():
        if user_state.is_working:
            user_state.end_time = now
            user_state.is_working = False
            if user_state.current_break:
                user_state.breaks[user_state.current_break] += now - user_state.break_start_time
                user_state.current_break = None
                user_state.break_start_time = None
            save_user_state(hashed_user_id, user_state)
    
    logger.info("ƒê√£ k·∫øt th√∫c ca l√†m vi·ªác cho t·∫•t c·∫£ ng∆∞·ªùi d√πng")
    await update.message.reply_text("ƒê√£ k·∫øt th√∫c ca l√†m vi·ªác cho t·∫•t c·∫£ ng∆∞·ªùi d√πng.")
    await notify_admin(context, "üèÅ ƒê√£ k·∫øt th√∫c ca l√†m vi·ªác cho t·∫•t c·∫£ ng∆∞·ªùi d√πng.")

async def all_eat(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    if user_id != MAIN_ADMIN_ID:
        await update.message.reply_text("B·∫°n kh√¥ng c√≥ quy·ªÅn th·ª±c hi·ªán h√†nh ƒë·ªông n√†y.")
        return

    now = datetime.now(VN_TIMEZONE)
    for hashed_user_id, user_state in user_states.items():
        if user_state.is_working and not user_state.current_break:
            user_state.current_break = 'üçö ƒÇn c∆°m (ÂêÉÈ•≠)'
            user_state.break_start_time = now
            user_state.break_counts['üçö ƒÇn c∆°m (ÂêÉÈ•≠)'] += 1
            save_user_state(hashed_user_id, user_state)
    
    logger.info("ƒê√£ b·∫Øt ƒë·∫ßu gi·ªù ƒÉn cho t·∫•t c·∫£ ng∆∞·ªùi d√πng ƒëang l√†m vi·ªác")
    await update.message.reply_text("ƒê√£ b·∫Øt ƒë·∫ßu gi·ªù ƒÉn cho t·∫•t c·∫£ ng∆∞·ªùi d√πng ƒëang l√†m vi·ªác.")
    await notify_admin(context, "üçö ƒê√£ b·∫Øt ƒë·∫ßu gi·ªù ƒÉn cho t·∫•t c·∫£ ng∆∞·ªùi d√πng ƒëang l√†m vi·ªác.")

async def auto_end_shift(context: ContextTypes.DEFAULT_TYPE):
    now = datetime.now(VN_TIMEZONE)
    for hashed_user_id, user_state in user_states.items():
        if user_state.is_working:
            user_state.end_time = now
            user_state.is_working = False
            if user_state.current_break:
                user_state.breaks[user_state.current_break] += now - user_state.break_start_time
                user_state.current_break = None
                user_state.break_start_time = None
            
            report = generate_simple_report(user_state, hashed_user_id)
            save_user_state(hashed_user_id, user_state)
            
            try:
                await context.bot.send_message(chat_id=int(hashed_user_id, 16), text=report)
            except Exception as e:
                logger.error(f"Kh√¥ng th·ªÉ g·ª≠i b√°o c√°o cho user {user_state.user_name}: {str(e)}")

async def send_daily_report(context: ContextTypes.DEFAULT_TYPE):
    now = datetime.now(VN_TIMEZONE)
    yesterday = now - timedelta(days=1)
    report = f"üìä B√°o c√°o cu·ªëi ng√†y {yesterday.strftime('%d/%m/%Y')}:\n\n"

    user_reports = []
    for hashed_user_id, user_state in user_states.items():
        if user_state.start_time and user_state.start_time.date() == yesterday.date():
            user_report = generate_simple_report(user_state, hashed_user_id)
            if user_report:
                user_reports.append(user_report)

    if user_reports:
        report += "\n".join(user_reports)
    else:
        report += "Kh√¥ng c√≥ d·ªØ li·ªáu b√°o c√°o cho ng√†y h√¥m qua."

    await notify_admin(context, report, notify_all=True)

    # Reset user states for the new day
    for user_state in user_states.values():
        user_state.start_time = None
        user_state.end_time = None
    user_state.breaks = {k: timedelta(0) for k in BREAK_DURATIONS.keys()}
    user_state.current_break = None
    user_state.break_start_time = None
    user_state.is_working = False
    user_state.break_counts = {k: 0 for k in BREAK_DURATIONS.keys()}

def main():
    init_db()
    global user_states
    user_states = load_user_states()

    application = Application.builder().token(BOT_TOKEN).build()

    application.add_handler(CommandHandler("start", start))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))
    application.add_handler(CallbackQueryHandler(button_callback))

    job_queue = application.job_queue
    job_queue.run_repeating(periodic_check, interval=timedelta(minutes=15), first=10)
    job_queue.run_repeating(save_all_user_states, interval=timedelta(minutes=5), first=5)
    
    # Th√™m job ƒë·ªÉ t·ª± ƒë·ªông k·∫øt th√∫c ca l√†m vi·ªác l√∫c 1:00 AM
    job_queue.run_daily(auto_end_shift, time=time(hour=1, minute=0))
    
    # C·∫≠p nh·∫≠t job g·ª≠i b√°o c√°o h√†ng ng√†y ƒë·ªÉ ch·∫°y l√∫c 1:05 AM
    job_queue.run_daily(send_daily_report, time=time(hour=1, minute=5))

    application.add_error_handler(error_handler)

    application.run_polling()

if __name__ == '__main__':
    main()