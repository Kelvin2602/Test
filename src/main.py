#!/usr/bin/env python
# -*- coding: utf-8 -*-

import asyncio
from telegram import Update, ReplyKeyboardMarkup, KeyboardButton, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import (
    Application,
    CommandHandler,
    MessageHandler,
    filters,
    ContextTypes,
    CallbackQueryHandler
)
from dataclasses import dataclass, field
from datetime import datetime, timedelta, date, time
import pytz
import logging
from logging.handlers import RotatingFileHandler
import coloredlogs
import sqlite3
import hashlib
import os
from pathlib import Path
import configparser
from tabulate import tabulate
import emoji
import json
from telegram.error import Forbidden, BadRequest
import subprocess
import pkg_resources
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
import shutil
from dotenv import load_dotenv
import time as systime
import pickle
import sys
import codecs
from typing import Dict
from .models import UserState, Violation
from src.services.violation_manager import ViolationManager
from src.utils.helpers import (
    save_user_states,
    generate_today_stats,
    generate_weekly_report,
    generate_daily_report
)

# Th√™m th∆∞ m·ª•c g·ªëc v√†o PYTHONPATH
BASE_DIR = Path(__file__).parent.parent
sys.path.append(str(BASE_DIR))

from src.admin_handlers import AdminHandlers
from src.utils.config import (
    BOT_TOKEN, 
    ADMIN_ID,
    MAIN_ADMIN_ID,
    VN_TIMEZONE,
    BREAK_DURATIONS,
    BREAK_FREQUENCIES
)

# Load environment variables
load_dotenv()

# C·∫•u h√¨nh base directory
BASE_DIR = Path(__file__).parent.parent
STATE_FILE = BASE_DIR / 'data' / 'user_states.pkl'
HISTORY_FILE = BASE_DIR / 'data' / 'attendance_history.json'

# T·∫°o th∆∞ m·ª•c data v√† logs n·∫øu ch∆∞a t·ªìn t·∫°i
(BASE_DIR / 'data').mkdir(exist_ok=True)
(BASE_DIR / 'logs').mkdir(exist_ok=True)

# C·∫•u h√¨nh ƒë·ªÉ x·ª≠ l√Ω Unicode tr√™n Windows
sys.stdout = codecs.getwriter('utf-8')(sys.stdout.buffer, 'strict')
sys.stderr = codecs.getwriter('utf-8')(sys.stderr.buffer, 'strict')

# C·∫•u h√¨nh logging
logger = logging.getLogger(__name__)
coloredlogs.install(level='DEBUG', logger=logger,
                   fmt='%(asctime)s - %(name)s - %(levelname)s - %(message)s')

# Th√™m file handler ƒë·ªÉ l∆∞u log
log_file = BASE_DIR / 'logs' / 'bot.log'
file_handler = RotatingFileHandler(log_file, maxBytes=10*1024*1024, backupCount=5, encoding='utf-8')
file_handler.setFormatter(logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s'))
logger.addHandler(file_handler)

# Kh·ªüi t·∫°o violation manager
violation_manager = ViolationManager()

# Kh·ªüi t·∫°o bi·∫øn user_states to√†n c·ª•c
user_states: Dict[str, UserState] = {}

def save_user_states(state: dict) -> None:
    """L∆∞u tr·∫°ng th√°i ng∆∞·ªùi d√πng"""
    try:
        # Gi·ªØ nguy√™n code x·ª≠ l√Ω hi·ªán t·∫°i c·ªßa b·∫°n
        pass
    except Exception as e:
        logging.error(f"L·ªói khi l∆∞u user states: {str(e)}")

def load_user_states():
    """ƒê·ªçc tr·∫°ng th√°i ng∆∞·ªùi d√πng t·ª´ file"""
    global user_states
    if os.path.exists(STATE_FILE):
        try:
            with open(STATE_FILE, 'rb') as f:
                user_states = pickle.load(f)
        except Exception as e:
            logger.error(f"L·ªói khi ƒë·ªçc user states: {e}")
            user_states = {}

# Initialize bot application
application = Application.builder().token(BOT_TOKEN).build()

# Load user states
load_user_states()

# Initialize admin handlers 
admin_handlers = AdminHandlers(application, user_states)

# Log current state
logging.info(f"Loaded {len(user_states)} user states")

async def is_admin(update: Update, context: ContextTypes.DEFAULT_TYPE) -> bool:
    """Check if user is admin"""
    return update.effective_user.id in ADMIN_ID

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """X·ª≠ l√Ω l·ªánh /start"""
    keyboard = [
        [
            KeyboardButton("üöÄ L√™n ca (‰∏äÁè≠)"),
            KeyboardButton("üèÅ Xu·ªëng ca (‰∏ãÁè≠)")
        ],
        [
            KeyboardButton("üçö ƒÇn c∆°m (ÂêÉÈ•≠)"),
            KeyboardButton("üö¨ H√∫t thu·ªëc (ÊäΩÁÉü)")
        ],
        [
            KeyboardButton("‚Ü©Ô∏è Tr·ªü l·∫°i ch·ªó ng·ªìi (ËøîÂõû)"),
            KeyboardButton("üöΩ V·ªá sinh (ÂéïÊâÄ)")
        ]
    ]
    reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
    await update.message.reply_text(
        "Ch√†o m·ª´ng! Vui l√≤ng ch·ªçn thao t√°c:",
        reply_markup=reply_markup
    )

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = update.message.text
    user = update.effective_user
    user_id = str(user.id)
    
    if user_id not in user_states:
        user_states[user_id] = UserState(user_name=user.full_name)
    
    state = user_states[user_id]
    now = datetime.now(VN_TIMEZONE)
    
    # X·ª≠ l√Ω c√°c n√∫t ch√≠nh
    if text == "üöÄ L√™n ca (‰∏äÁè≠)":
        await handle_start_shift(update, state, now)
    
    elif text == "üèÅ Xu·ªëng ca (‰∏ãÁè≠)":
        await handle_end_shift(update, state, now)
        
    elif text == "üçö ƒÇn c∆°m (ÂêÉÈ•≠)":
        await handle_break(update, state, now, "üçö ƒÇn c∆°m (ÂêÉÈ•≠)", context)
        
    elif text == "üö¨ H√∫t thu·ªëc (ÊäΩÁÉü)":
        await handle_break(update, state, now, "üö¨ H√∫t thu·ªëc (ÊäΩÁÉü)", context)
        
    elif text == "üöΩ V·ªá sinh (ÂéïÊâÄ)":
        await handle_break(update, state, now, "üöΩ V·ªá sinh (ÂéïÊâÄ)", context)
        
    elif text == "‚Ü©Ô∏è Tr·ªü l·∫°i ch·ªó ng·ªìi (ËøîÂõû)":
        await handle_end_break(update, state, now, context)

async def handle_start_shift(update, state, now):
    """X·ª≠ l√Ω l√™n ca"""
    if state.is_working:
        await update.message.reply_text("‚ùå B·∫°n ƒë√£ b·∫Øt ƒë·∫ßu ca l√†m vi·ªác r·ªìi!")
        return
        
    state.is_working = True
    state.start_time = now
    state.breaks = {k: timedelta(0) for k in BREAK_DURATIONS.keys()}
    state.break_counts = {k: 0 for k in BREAK_DURATIONS.keys()}
    save_user_states(state)
    
    await update.message.reply_text(
        f"‚úÖ ƒê√£ b·∫Øt ƒë·∫ßu ca l√†m vi·ªác l√∫c {now.strftime('%H:%M:%S')}"
    )

async def handle_end_shift(update, state, now):
    """X·ª≠ l√Ω xu·ªëng ca"""
    if not state.is_working:
        await update.message.reply_text("‚ùå B·∫°n ch∆∞a b·∫Øt ƒë·∫ßu ca l√†m vi·ªác!")
        return
            
    if state.current_break:
        await update.message.reply_text("‚ùå Vui l√≤ng k·∫øt th√∫c gi·ªù ngh·ªâ tr∆∞·ªõc khi k·∫øt th√∫c ca!")
        return
        
    state.is_working = False
    state.end_time = now
    total_time = now - state.start_time
    total_breaks = sum(state.breaks.values(), timedelta())
    work_time = total_time - total_breaks
    
    report = (
        f"üìã B√°o c√°o ca l√†m vi·ªác:\n"
        f"‚è∞ Th·ªùi gian b·∫Øt ƒë·∫ßu: {state.start_time.strftime('%H:%M:%S')}\n"
        f"‚åõÔ∏è Th·ªùi gian k·∫øt th√∫c: {now.strftime('%H:%M:%S')}\n"
        f"‚è± T·ªïng th·ªùi gian: {str(total_time).split('.')[0]}\n"
        f"üöΩ T·ªïng th·ªùi gian ngh·ªâ: {str(total_breaks).split('.')[0]}\n"
        f"üí™ Th·ªùi gian l√†m vi·ªác th·ª±c t·∫ø: {str(work_time).split('.')[0]}\n\n"
        f"üìä Chi ti·∫øt gi·ªù ngh:"
    )
    
    for break_type, duration in state.breaks.items():
        if duration > timedelta(0):
            report += f"\n{break_type}: {str(duration).split('.')[0]}"
    
    save_user_states(state)
    await update.message.reply_text(report)

async def handle_break(update, state, now, break_type, context: ContextTypes.DEFAULT_TYPE):
    """X·ª≠ l√Ω c√°c lo·∫°i ngh·ªâ"""
    if not state.is_working:
        await update.message.reply_text("‚ùå B·∫°n ch∆∞a b·∫Øt ƒë·∫ßu ca l√†m vi·ªác!")
        return
        
    if state.current_break:
        await update.message.reply_text("‚ùå B·∫°n ƒëang trong gi·ªù ngh·ªâ!")
        return
        
    current_count = state.break_counts.get(break_type, 0)
    state.current_break = break_type
    state.break_start_time = now
    state.break_counts[break_type] = current_count + 1
    save_user_states(state)
    
    duration = BREAK_DURATIONS[break_type]
    message = f"‚úÖ B·∫Øt ƒë·∫ßu {break_type}\n‚è∞ Th·ªùi gian cho ph√©p: {duration} ph√∫t\n"
    message += f"üìä S·ªë l·∫ßn ƒë√£ ngh·ªâ: {current_count + 1}/{BREAK_FREQUENCIES[break_type]}"
    
    if current_count >= BREAK_FREQUENCIES[break_type]:
        # Th√™m c·∫£nh b√°o n·∫øu v∆∞·ª£t s·ªë l·∫ßn cho ph√©p
        message = "‚ö†Ô∏è C·∫¢NH B√ÅO: " + message
        message += f"\n‚ùå B·∫°n ƒë√£ v∆∞·ª£t qu√° s·ªë l·∫ßn {break_type} cho ph√©p!"
        
        # Th√¥ng b√°o admin
        await notify_admins_violation(
            context,
            state.user_name,
            f"‚ùå V∆∞·ª£t s·ªë l·∫ßn {break_type} ({current_count + 1}/{BREAK_FREQUENCIES[break_type]})"
        )
    
    await update.message.reply_text(message)

async def handle_end_break(update, state, now, context):
    """X·ª≠ l√Ω k·∫øt th√∫c ngh·ªâ"""
    if not state.current_break:
        await update.message.reply_text("‚ùå B·∫°n kh√¥ng trong gi·ªù ngh·ªâ!")
        return
        
    break_duration = now - state.break_start_time
    state.breaks[state.current_break] += break_duration
    allowed_duration = timedelta(minutes=BREAK_DURATIONS[state.current_break])
    
    if break_duration > allowed_duration:
        overtime = break_duration - allowed_duration
        await update.message.reply_text(
            f"‚ö†Ô∏è C·∫£nh b√°o: B·∫°n ƒë√£ ngh·ªâ qu√° gi·ªù {str(overtime).split('.')[0]}"
        )
        # Th√¥ng b√°o admin khi qu√° gi·ªù
        await notify_admins_violation(
            context,
            state.user_name,
            f"‚è∞ Ngh·ªâ qu√° gi·ªù {str(overtime).split('.')[0]} (cho ph√©p {BREAK_DURATIONS[state.current_break]} ph√∫t)"
        )
    
    state.current_break = None
    state.break_start_time = None
    save_user_states(state)
    
    await update.message.reply_text(
        f"‚úÖ ƒê√£ k·∫øt th√∫c ngh·ªâ\n"
        f"‚è± Th·ªùi gian ngh·ªâ: {str(break_duration).split('.')[0]}"
    )

async def handle_admin_action(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """X·ª≠ l√Ω c√°c action t·ª´ menu admin"""
    query = update.callback_query
    action = query.data
    
    if not admin_handlers:
        await query.answer("‚ùå L·ªói: Admin handlers ch∆∞a ƒë∆∞·ª£c kh·ªüi t·∫°o!")
        return
        
    try:
        # Map action v·ªõi h√†m x·ª≠ l√Ω t∆∞∆°ng ·ª©ng
        action_handlers = {
            "all_start_shift": admin_handlers.handle_all_start_shift,
            "all_end_shift": admin_handlers.handle_all_end_shift,
            "force_break": admin_handlers.handle_force_break,
            "end_break": admin_handlers.handle_end_break,
            "today_stats": admin_handlers.handle_today_stats,
            "all_stats": admin_handlers.handle_all_stats,
            "daily_report": admin_handlers.handle_daily_report,
            "weekly_report": admin_handlers.handle_weekly_report,
            "back_admin": admin_handlers.admin_menu,
            "confirm_reset": admin_handlers.handle_reset_callback,
            "cancel_reset": admin_handlers.handle_reset_callback,
            "admin_shift": admin_handlers.handle_shift_menu,
            "admin_break": admin_handlers.handle_break_menu,
            "admin_stats": admin_handlers.handle_stats_menu,
            "admin_report": admin_handlers.handle_report_menu
        }
        
        if action in action_handlers:
            await action_handlers[action](update, context)
            
    except Exception as e:
        logger.error(f"L·ªói khi x·ª≠ l√Ω admin action: {e}")
        await query.answer("‚ùå ƒê√£ x·∫£y ra l·ªói khi th·ª±c hi·ªán h√†nh ƒë·ªông!")

async def button_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """X·ª≠ l√Ω callback t·ª´ c√°c n√∫t b·∫•m"""
    query = update.callback_query
    
    try:
        # Ki·ªÉm tra n·∫øu l√† callback t·ª´ menu admin
        if query.data.startswith('admin_'):
            if admin_handlers:
                await admin_handlers.admin_button_callback(update, context)
            return
        elif query.data in ["all_start_shift", "all_end_shift", 
                          "force_break", "end_break",
                          "today_stats", "all_stats",
                          "daily_report", "weekly_report"]:
            await handle_admin_action(update, context)
            return
            
        await query.answer()
    except Exception as e:
        logger.error(f"L·ªói khi x·ª≠ l√Ω callback: {e}")
        await query.answer("‚ùå ƒê√£ x·∫£y ra l·ªói!")

async def handle_violation_report(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Xem b√°o c√°o vi ph·∫°m"""
    if update.effective_user.id not in ADMIN_ID:
        await update.message.reply_text("‚õîÔ∏è B·∫°n kh√¥ng c√≥ quy·ªÅn xem b√°o c√°o!")
        return
        
    # L·∫•y b√°o c√°o vi ph·∫°m trong ng√†y
    start_of_day = datetime.now(VN_TIMEZONE).replace(
        hour=0, minute=0, second=0, microsecond=0
    )
    report = violation_manager.generate_violation_report(start_of_day)
    
    await update.message.reply_text(report)

async def periodic_check(context: ContextTypes.DEFAULT_TYPE):
    """Ki·ªÉm tra ƒë·ªãnh k·ª≥ c√°c vi ph·∫°m"""
    now = datetime.now(VN_TIMEZONE)
    for user_id, state in user_states.items():
        if state.is_working and state.current_break:
            break_duration = now - state.break_start_time
            allowed_duration = timedelta(minutes=BREAK_DURATIONS[state.current_break])
            if break_duration > allowed_duration:
                try:
                    await context.bot.send_message(
                        chat_id=user_id,
                        text=f"‚ö†Ô∏è C·∫£nh b√°o: B·∫°n ƒë√£ ngh·ªâ qu√° gi·ªù {str(break_duration - allowed_duration).split('.')[0]}"
                    )
                except (Forbidden, BadRequest):
                    logger.warning(f"Kh√¥ng th·ªÉ g·ª≠i c·∫£nh b√°o t·ªõi user {user_id}")

async def save_all_user_states(context: ContextTypes.DEFAULT_TYPE):
    """L∆∞u tr·∫°ng th√°i t·∫•t c·∫£ users ƒë·ªãnh k·ª≥"""
    try:
        active_users = len([u for u in user_states.values() if u.is_working])
        logger.info(f"ƒêang l∆∞u tr·∫°ng th√°i: {len(user_states)} users, {active_users} ƒëang ho·∫°t ƒë·ªông")
        save_user_states(user_states)
    except Exception as e:
        logger.error(f"L·ªói khi l∆∞u user states: {e}")

async def auto_end_shift(context: ContextTypes.DEFAULT_TYPE):
    """T·ª± ƒë·ªông k·∫øt th√∫c ca l√†m vi·ªác l√∫c 1h s√°ng"""
    now = datetime.now(VN_TIMEZONE)
    count = 0
    for user_id, state in user_states.items():
        if state.is_working:
            state.is_working = False
            state.end_time = now
            count += 1
            try:
                await context.bot.send_message(
                    chat_id=user_id,
                    text="üîî Ca l√†m vi·ªác c·ªßa b·∫°n ƒë√£ ƒë∆∞·ª£c t·ª± ƒë·ªông k·∫øt th√∫c"
                )
            except (Forbidden, BadRequest):
                logger.warning(f"Kh√¥ng th·ªÉ g·ª≠i th√¥ng b√°o t·ªõi user {user_id}")
    
    save_user_states()
    logger.info(f"ƒê√£ t·ª± ƒë·ªông k·∫øt th√∫c ca cho {count} ng∆∞·ªùi")

async def send_daily_report(context: ContextTypes.DEFAULT_TYPE):
    """G·ª≠i b√°o c√°o h√†ng ng√†y cho admin"""
    yesterday = datetime.now(VN_TIMEZONE) - timedelta(days=1)
    
    # T·∫°o b√°o c√°o vi ph·∫°m
    violation_report = violation_manager.generate_violation_report(yesterday)
    
    # T·∫°o b√°o c√°o t·ªïng h·ª£p
    daily_report = generate_daily_report(user_states)
    
    final_report = f"üìä B√°o c√°o ng√†y {yesterday.strftime('%d/%m/%Y')}:\n\n"
    final_report += daily_report + "\n\n"
    final_report += "üö´ B√°o c√°o vi ph·∫°m:\n" + violation_report
    
    for admin_id in ADMIN_ID:
        try:
            await context.bot.send_message(
                chat_id=admin_id,
                text=final_report
            )
        except (Forbidden, BadRequest):
            logger.warning(f"Kh√¥ng th·ªÉ g·ª≠i b√°o c√°o t·ªõi admin {admin_id}")

async def notify_admins_violation(context: ContextTypes.DEFAULT_TYPE, user_name: str, violation_msg: str):
    """G·ª≠i th√¥ng b√°o vi ph·∫°m t·ªõi admin"""
    message = f"‚ö†Ô∏è VI PH·∫†M\n {user_name}\n{violation_msg}"
    
    for admin_id in ADMIN_ID:
        try:
            await context.bot.send_message(
                chat_id=admin_id,
                text=message
            )
        except (Forbidden, BadRequest):
            logger.warning(f"Kh√¥ng th·ªÉ g·ª≠i th√¥ng b√°o vi ph·∫°m t·ªõi admin {admin_id}")

async def get_chat_members(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """L·∫•y danh s√°ch th√†nh vi√™n trong group"""
    try:
        chat_id = update.effective_chat.id
        members = await context.bot.get_chat_administrators(chat_id)
        logging.info(f"Got {len(members)} chat members")
        return members
    except Exception as e:
        logging.error(f"L·ªói khi l·∫•y danh s√°ch th√†nh vi√™n: {e}")
        return []

async def handle_all_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """L·ªánh admin cho t·∫•t c·∫£ l√™n ca"""
    try:
        # Ki·ªÉm tra quy·ªÅn admin
        if not await is_admin(update, context):
            return
            
        # L·∫•y danh s√°ch th√†nh vi√™n
        chat_members = await get_chat_members(update, context)
        logging.info(f"Processing {len(chat_members)} members for all start")
        
        count = 0
        for member in chat_members:
            if not member.user.is_bot:
                user_id = member.user.id
                user_states[user_id] = {
                    'is_working': True,
                    'start_time': datetime.now(),
                    'break_time': 0
                }
                count += 1
        
        save_user_states(user_states)
        await update.message.reply_text(f"‚úÖ ƒê√£ cho {count} ng∆∞·ªùi l√™n ca!")
        
    except Exception as e:
        logging.error(f"L·ªói khi cho t·∫•t c·∫£ l√™n ca: {e}")
        await update.message.reply_text("‚ùå C√≥ l·ªói x·∫£y ra!")

def check_working_status(user_id: int) -> bool:
    """Ki·ªÉm tra user ƒë√£ l√™n ca ch∆∞a"""
    return (user_id in user_states and 
            user_states[user_id].get('is_working', False))

async def handle_end_work(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    
    # Ki·ªÉm tra ƒë√£ l√™n ca ch∆∞a
    if not check_working_status(user_id):
        await update.message.reply_text("‚ùå B·∫°n ch∆∞a b·∫Øt ƒë·∫ßu ca l√†m vi·ªác!")
        return
    
    # X·ª≠ l√Ω xu·ªëng ca
    # ... code x·ª≠ l√Ω ...

if __name__ == "__main__":
    # Kh·ªüi t·∫°o logging
    logging.info("Starting bot...")
    
    # Load tr·∫°ng th√°i user
    load_user_states()
    
    # Log tr·∫°ng th√°i hi·ªán t·∫°i
    logging.info(f"Loaded {len(user_states)} user states")